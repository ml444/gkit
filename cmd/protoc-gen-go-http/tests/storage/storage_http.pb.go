// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v1.1.0
// - protoc             v4.25.2
// source: storage/storage.proto

package storage

import (
	context "context"
	pluck "github.com/ml444/gkit/cmd/protoc-gen-go-http/pluck"
	middleware "github.com/ml444/gkit/middleware"
	transport "github.com/ml444/gkit/transport"
	httpx "github.com/ml444/gkit/transport/httpx"
	http "net/http"
)

var _ = new(http.Request)
var _ = new(context.Context)
var _ = make([]middleware.Middleware, 0)
var _ transport.Server = new(httpx.Server)
var _ = pluck.DisablePluckHeader

const OperationStorageDownloadV0 = "/storage.storage/DownloadV0"
const OperationStorageDownloadV1 = "/storage.storage/DownloadV1"
const OperationStorageDownloadV2 = "/storage.storage/DownloadV2"
const OperationStorageUploadV0 = "/storage.storage/UploadV0"
const OperationStorageUploadV1 = "/storage.storage/UploadV1"
const OperationStorageUploadV2 = "/storage.storage/UploadV2"

type StorageHTTPServer interface {
	// DownloadV0 @desc: Download the file, and the binary file is placed in a field in the response body.
	DownloadV0(context.Context, *DownloadReq) (*DownloadRsp, error)
	// DownloadV1 @desc: Download the file and specify `responseBody` through `google.api.http`.
	// The binary data will be extracted from the specified field and put into
	// the body of the response. At the same time, you can set the relevant
	// response headers by configuring `pluck.response.headers_from`.
	DownloadV1(context.Context, *DownloadReq) (*DownloadRsp, error)
	// DownloadV2 @desc: download the excel file, and set the response header `Content-Type` to `application/vnd.openxmlformats`.
	DownloadV2(context.Context, *DownloadReq) (*DownloadRsp, error)
	// UploadV0 @desc: Ordinary upload method
	UploadV0(context.Context, *UploadReq) (*UploadRsp, error)
	// UploadV1 @desc: Upload file information through the header, and upload file
	// content through the body. Use the body field of google.api.http to
	// specify the field name of the body. You need to specify the
	// Content-Type as `application/octet-stream`.
	UploadV1(context.Context, *UploadReq) (*UploadRsp, error)
	// UploadV2 @desc: Upload file information through the header,
	// and specify the body field as `*` to upload the file content.
	// then pluck will extract the file content from the body
	// and save to specified field.
	UploadV2(context.Context, *UploadReq) (*UploadRsp, error)
}

func RegisterStorageHTTPServer(s *httpx.Server, srv StorageHTTPServer) {
	r := s.GetRouter()
	r.POST("/storage/upload/v0", Storage_UploadV00_HTTP_Handler(srv, s.Middlewares()...))
	r.POST("/storage/upload/v1", Storage_UploadV10_HTTP_Handler(srv, s.Middlewares()...))
	r.POST("/storage/upload/v2", Storage_UploadV20_HTTP_Handler(srv, s.Middlewares()...))
	r.POST("/storage/download/v0", Storage_DownloadV00_HTTP_Handler(srv, s.Middlewares()...))
	r.POST("/storage/download/v1", Storage_DownloadV10_HTTP_Handler(srv, s.Middlewares()...))
	r.POST("/storage/download/v2", Storage_DownloadV20_HTTP_Handler(srv, s.Middlewares()...))
}

func Storage_UploadV00_HTTP_Handler(srv StorageHTTPServer, mws ...middleware.Middleware) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var in UploadReq
		ctx := httpx.NewCtx(w, r)
		if err := ctx.Bind(&in); err != nil {
			ctx.ReturnError(err)
			return
		}
		if err := ctx.BindQuery(&in); err != nil {
			ctx.ReturnError(err)
			return
		}
		httpx.SetOperation(ctx, OperationStorageUploadV0)
		handler := middleware.Chain(mws...)(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UploadV0(ctx, req.(*UploadReq))
		})

		if err := ctx.Returns(handler(ctx, &in)); err != nil {
			ctx.ReturnError(err)
		}
		return
	}
}

func Storage_UploadV10_HTTP_Handler(srv StorageHTTPServer, mws ...middleware.Middleware) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var in UploadReq
		ctx := httpx.NewCtx(w, r)
		if err := ctx.Bind(&in.FileData); err != nil {
			ctx.ReturnError(err)
			return
		}
		if err := ctx.BindQuery(&in); err != nil {
			ctx.ReturnError(err)
			return
		}
		httpx.SetOperation(ctx, OperationStorageUploadV1)
		handler := middleware.Chain(mws...)(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UploadV1(ctx, req.(*UploadReq))
		})

		pluck.ExtractHeader(r.Header, &in.FileInfo)
		if err := ctx.Returns(handler(ctx, &in)); err != nil {
			ctx.ReturnError(err)
		}
		return
	}
}

func Storage_UploadV20_HTTP_Handler(srv StorageHTTPServer, mws ...middleware.Middleware) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var in UploadReq
		ctx := httpx.NewCtx(w, r)
		if err := ctx.BindQuery(&in); err != nil {
			ctx.ReturnError(err)
			return
		}
		httpx.SetOperation(ctx, OperationStorageUploadV2)
		handler := middleware.Chain(mws...)(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UploadV2(ctx, req.(*UploadReq))
		})

		pluck.ExtractHeader(r.Header, &in.FileInfo)
		data, err := pluck.CopyBodyFromRequest(r)
		if err != nil {
			ctx.ReturnError(err)
			return
		}
		in.FileData = data
		if err := ctx.Returns(handler(ctx, &in)); err != nil {
			ctx.ReturnError(err)
		}
		return
	}
}

func Storage_DownloadV00_HTTP_Handler(srv StorageHTTPServer, mws ...middleware.Middleware) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var in DownloadReq
		ctx := httpx.NewCtx(w, r)
		if err := ctx.Bind(&in); err != nil {
			ctx.ReturnError(err)
			return
		}
		if err := ctx.BindQuery(&in); err != nil {
			ctx.ReturnError(err)
			return
		}
		httpx.SetOperation(ctx, OperationStorageDownloadV0)
		handler := middleware.Chain(mws...)(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DownloadV0(ctx, req.(*DownloadReq))
		})

		if err := ctx.Returns(handler(ctx, &in)); err != nil {
			ctx.ReturnError(err)
		}
		return
	}
}

func Storage_DownloadV10_HTTP_Handler(srv StorageHTTPServer, mws ...middleware.Middleware) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var in DownloadReq
		ctx := httpx.NewCtx(w, r)
		if err := ctx.Bind(&in); err != nil {
			ctx.ReturnError(err)
			return
		}
		if err := ctx.BindQuery(&in); err != nil {
			ctx.ReturnError(err)
			return
		}
		httpx.SetOperation(ctx, OperationStorageDownloadV1)
		handler := middleware.Chain(mws...)(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DownloadV1(ctx, req.(*DownloadReq))
		})

		out, err := handler(ctx, &in)
		if err != nil {
			ctx.ReturnError(err)
			return
		}
		err = pluck.SetResponseHeaders(w, out.(*DownloadRsp).Headers)
		if err != nil {
			ctx.ReturnError(err)
			return
		}
		w.Write(out.(*DownloadRsp).Data)
		return
	}
}

func Storage_DownloadV20_HTTP_Handler(srv StorageHTTPServer, mws ...middleware.Middleware) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var in DownloadReq
		ctx := httpx.NewCtx(w, r)
		if err := ctx.Bind(&in); err != nil {
			ctx.ReturnError(err)
			return
		}
		if err := ctx.BindQuery(&in); err != nil {
			ctx.ReturnError(err)
			return
		}
		httpx.SetOperation(ctx, OperationStorageDownloadV2)
		handler := middleware.Chain(mws...)(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DownloadV2(ctx, req.(*DownloadReq))
		})

		out, err := handler(ctx, &in)
		if err != nil {
			ctx.ReturnError(err)
			return
		}
		w.Header().Set("Access-Control-Expose-Headers", "Content-Disposition")
		w.Header().Set("Content-Type", "application/vnd.openxmlformats")
		err = pluck.SetResponseHeaders(w, out.(*DownloadRsp).Headers)
		if err != nil {
			ctx.ReturnError(err)
			return
		}
		w.Write(out.(*DownloadRsp).Data)
		return
	}
}

type StorageHTTPClient interface {
	DownloadV0(ctx context.Context, req *DownloadReq, opts ...httpx.CallOption) (rsp *DownloadRsp, err error)
	DownloadV1(ctx context.Context, req *DownloadReq, opts ...httpx.CallOption) (rsp *DownloadRsp, err error)
	DownloadV2(ctx context.Context, req *DownloadReq, opts ...httpx.CallOption) (rsp *DownloadRsp, err error)
	UploadV0(ctx context.Context, req *UploadReq, opts ...httpx.CallOption) (rsp *UploadRsp, err error)
	UploadV1(ctx context.Context, req *UploadReq, opts ...httpx.CallOption) (rsp *UploadRsp, err error)
	UploadV2(ctx context.Context, req *UploadReq, opts ...httpx.CallOption) (rsp *UploadRsp, err error)
}

type StorageHTTPClientImpl struct {
	cc *httpx.Client
}

func NewStorageHTTPClient(client *httpx.Client) StorageHTTPClient {
	return &StorageHTTPClientImpl{client}
}

func (c *StorageHTTPClientImpl) DownloadV0(ctx context.Context, in *DownloadReq, opts ...httpx.CallOption) (*DownloadRsp, error) {
	var err error
	var out DownloadRsp
	pattern := "/storage/download/v0"
	path := httpx.EncodeURL(pattern, in, false)
	opts = append(opts, httpx.Operation(OperationStorageDownloadV0))
	opts = append(opts, httpx.PathTemplate(pattern))
	err = c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *StorageHTTPClientImpl) DownloadV1(ctx context.Context, in *DownloadReq, opts ...httpx.CallOption) (*DownloadRsp, error) {
	var err error
	var out DownloadRsp
	pattern := "/storage/download/v1"
	path := httpx.EncodeURL(pattern, in, false)
	opts = append(opts, httpx.Operation(OperationStorageDownloadV1))
	opts = append(opts, httpx.PathTemplate(pattern))
	opts = append(opts, httpx.OnResponse(func(rsp *http.Response) error {
		return pluck.ExtractHeader(rsp.Header, out.Headers)
	}))
	err = c.cc.Invoke(ctx, "POST", path, in, &out.Data, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *StorageHTTPClientImpl) DownloadV2(ctx context.Context, in *DownloadReq, opts ...httpx.CallOption) (*DownloadRsp, error) {
	var err error
	var out DownloadRsp
	pattern := "/storage/download/v2"
	path := httpx.EncodeURL(pattern, in, false)
	opts = append(opts, httpx.Operation(OperationStorageDownloadV2))
	opts = append(opts, httpx.PathTemplate(pattern))
	opts = append(opts, httpx.OnResponse(func(rsp *http.Response) error {
		return pluck.ExtractHeader(rsp.Header, out.Headers)
	}))
	err = c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *StorageHTTPClientImpl) UploadV0(ctx context.Context, in *UploadReq, opts ...httpx.CallOption) (*UploadRsp, error) {
	var err error
	var out UploadRsp
	pattern := "/storage/upload/v0"
	path := httpx.EncodeURL(pattern, in, false)
	opts = append(opts, httpx.Operation(OperationStorageUploadV0))
	opts = append(opts, httpx.PathTemplate(pattern))
	err = c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *StorageHTTPClientImpl) UploadV1(ctx context.Context, in *UploadReq, opts ...httpx.CallOption) (*UploadRsp, error) {
	var err error
	var out UploadRsp
	pattern := "/storage/upload/v1"
	path := httpx.EncodeURL(pattern, in, false)
	opts = append(opts, httpx.Operation(OperationStorageUploadV1))
	opts = append(opts, httpx.PathTemplate(pattern))
	headers, err := pluck.ConvertAnyToHeader(in.FileInfo, true)
	if err != nil {
		return nil, err
	}
	opts = append(opts, httpx.RequestHeader(headers))

	opts = append(opts, httpx.AddRequestHeader("Content-Type", "application/octet-stream"))
	err = c.cc.Invoke(ctx, "POST", path, in.FileData, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *StorageHTTPClientImpl) UploadV2(ctx context.Context, in *UploadReq, opts ...httpx.CallOption) (*UploadRsp, error) {
	var err error
	var out UploadRsp
	pattern := "/storage/upload/v2"
	path := httpx.EncodeURL(pattern, in, false)
	opts = append(opts, httpx.Operation(OperationStorageUploadV2))
	opts = append(opts, httpx.PathTemplate(pattern))
	headers, err := pluck.ConvertAnyToHeader(in.FileInfo, true)
	if err != nil {
		return nil, err
	}
	opts = append(opts, httpx.RequestHeader(headers))

	err = c.cc.Invoke(ctx, "POST", path, in.FileData, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
