package main

import (
	"bytes"
	_ "embed"
	"fmt"
	"path/filepath"
	"strings"
	"text/template"

	"google.golang.org/protobuf/reflect/protoreflect"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"

	"github.com/ml444/gkit/cmd/protoc-gen-go-validate/ctx"
	"github.com/ml444/gkit/cmd/protoc-gen-go-validate/templates"
	"github.com/ml444/gkit/cmd/protoc-gen-go-validate/validate"
)

//go:embed validate.tmpl
var validateTemplate string

const Version = "1.0.0"
const deprecationComment = "// Deprecated: Do not use."

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Messages) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_validate.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-validate. DO NOT EDIT.")
	g.P(fmt.Sprintf("// - protoc-gen-go-validate %s", Version))
	g.P("// - protoc             ", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	tmpl := template.New("file")
	Register(tmpl)

	var err error
	buf := new(bytes.Buffer)
	tmpl, err = tmpl.Parse(templates.FileTmpl)
	if err != nil {
		panic(err.Error())
	}
	err = tmpl.Execute(buf, file)
	if err != nil {
		panic(err.Error())
	}
	g.P(buf.String())
	g.P()
	fileDir := string(file.GoImportPath)
	isRelative := isRelativePath(gen.Request.GetParameter())
	if isRelative {
		// TODO: --go-validate_out=paths=source_relative:./go
		fileDir, _ = filepath.Split(file.GeneratedFilenamePrefix)
	}
	exist, err := existValidationErrorInPackage(fileDir, file.GeneratedFilenamePrefix)
	if err != nil {
		panic(err.Error())
	}
	if !exist {
		g.P(templates.CommonDefTmpl)
	}
	generateFileContent(tmpl, file, g)
	return g
}

func generateFileContent(tmpl *template.Template, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Messages) == 0 {
		return
	}
	var err error
	tmpl, err = tmpl.New("validate").Parse(strings.TrimSpace(validateTemplate))
	if err != nil {
		panic(err.Error())
	}
	for _, message := range file.Messages {
		genMessage(tmpl, file, g, message)
	}
}

func genMessage(tmpl *template.Template, file *protogen.File, g *protogen.GeneratedFile, message *protogen.Message) {
	if message.Desc.Options().(*descriptorpb.MessageOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}

	msgData := &ctx.MessageCtx{
		Desc:           message.Desc,
		TypeName:       message.GoIdent.GoName,
		NonOneOfFields: []*ctx.FieldCtx{},
		RealOneOfs:     map[string]*ctx.OneOfField{},
		OptionalFields: []*ctx.FieldCtx{},
	}
	disabled, ok := proto.GetExtension(message.Desc.Options(), validate.E_Disabled).(bool)
	if ok {
		msgData.Disabled = disabled
	}
	ignored, ok := proto.GetExtension(message.Desc.Options(), validate.E_Ignored).(bool)
	if ok {
		msgData.Ignored = ignored
	}
	var needGen bool
	for _, field := range message.Fields {
		rule, ok := proto.GetExtension(field.Desc.Options(), validate.E_Rules).(*validate.FieldRules)
		if ok && rule != nil {
			needGen = true
			ruleType, ruleIns, messageRule, wrapped := ctx.ResolveRules(field.Desc, rule)
			fieldCtx := ctx.FieldCtx{
				Desc:     field.Desc,
				Field:    field,
				Rules:    ruleIns,
				Name:     field.GoName,
				Type:     field.Desc.Kind().String(),
				TmplName: ruleType,
				Err:      nil,
			}
			if wrapped {
				fieldCtx.Wrap = ruleType
				fieldCtx.TmplName = "wrapper"
			}
			if field.Enum != nil {
				fieldCtx.Type = field.Enum.GoIdent.GoName
			} else if field.Message != nil {
				fieldCtx.Type = field.Message.GoIdent.GoName
			}

			if messageRule != nil {
				if messageRule.Required != nil {
					fieldCtx.Required = *messageRule.Required
				}
				if messageRule.Skip != nil {
					fieldCtx.Skip = *messageRule.Skip
				}
			}
			msgData.Fields = append(msgData.Fields, &fieldCtx)
			if field.Oneof != nil {
				if field.Desc.Cardinality() == protoreflect.Optional && "_"+field.Desc.JSONName() == string(field.Oneof.Desc.Name()) {
					msgData.OptionalFields = append(msgData.OptionalFields, &fieldCtx)
				} else {
					handleOneOfs(field, &fieldCtx, msgData)
				}
			} else {
				msgData.NonOneOfFields = append(msgData.NonOneOfFields, &fieldCtx)
			}
		} else {
			if field.Oneof != nil {
				fieldCtx := ctx.FieldCtx{
					Desc:     field.Desc,
					Field:    field,
					Rules:    nil,
					Name:     field.GoName,
					Type:     field.Desc.Kind().String(),
					TmplName: "none",
					Err:      nil,
				}
				handleOneOfs(field, &fieldCtx, msgData)
			}

			if field.Desc.Kind() == protoreflect.MessageKind {
				fieldCtx := ctx.FieldCtx{
					Desc:  field.Desc,
					Rules: &validate.MessageRules{},
					Field: field,
					Name:  field.GoName,
					Type:  field.Desc.Kind().String(),
					//Required: *messageRule.Required,
					//Skip:     *messageRule.Skip,
					TmplName: "message",
					Err:      nil,
				}
				msgData.NonOneOfFields = append(msgData.NonOneOfFields, &fieldCtx)
			}
		}
	}

	if needGen {
		buf := new(bytes.Buffer)
		err := tmpl.Lookup("validate").Execute(buf, msgData)
		if err != nil {
			panic(err.Error())
		}
		_, err = g.Write(buf.Bytes())
		if err != nil {
			panic(err.Error())
		}
		for _, msg := range message.Messages {
			genMessage(tmpl, file, g, msg)
		}
	}
}

func handleOneOfs(field *protogen.Field, fieldCtx *ctx.FieldCtx, msgData *ctx.MessageCtx) {
	oneOf, ok := msgData.RealOneOfs[field.Oneof.GoName]
	if !ok {
		oneOf = &ctx.OneOfField{
			Fields: nil,
			Field:  field,
			Name:   field.Oneof.GoName,
			Type:   string(field.Oneof.Desc.Name()),
			//Required: *messageRule.Required,
			//Skip:     *messageRule.Skip,
			//TmplName: ruleType,
		}
	}
	required, ok := proto.GetExtension(field.Oneof.Desc.Options(), validate.E_Required).(bool)
	if ok {
		oneOf.Required = required
	}
	oneOf.Fields = append(oneOf.Fields, fieldCtx)
	msgData.RealOneOfs[oneOf.Name] = oneOf
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}
